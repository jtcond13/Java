Comp 500 -- HW #2

#1.  I implemented shell sort and merge sort in my sort Java class. My experimental results for shell sort were generated
with the suggested (Knuth) sequence (h = 1, 4, 13, 40, 121, 364 ...).  I then experimented with the Shell sequence,
which is an initial gap of N/2, divided in half on each pass (1000, 500, 250, ...).  As expected, this was significantly less efficient
(28k Comparisons and 10400 exchanges in the worst case).  Attempting other, arbitrary, sequences showed that the sequences
with more prime numbers were more efficient as there was less intermingling of items sorted on previous iterations.

Both algorithms compare favorably to Bubble Sort and Insertion sort, although neither have the same O(n) efficiency
with respect to exchanges seen in selection sort.  Merge sort is O(nlogn); shell sort varies depending on the input and sequence, but always performs
better than the O(N^2) performance seen in elementary sorts.


Shell Sort:

Worst Case
Comparisons: 19648
Exchanges: 7284

Average Case
Comparisons: 33373
Exchanges: 21009

Best Case
Comparisons: 12364
Exchanges: 0

Merge Sort:

Best Case
Comparisons: 11088
Exchanges: 43904

Average Case
Comparisons: 19404
Exchanges: 43904

Worst Case
Comparisons: 10864
Exchanges: 43904

#2.  A recursive method for finding the largest element in an array might look like:

  findMax(array, low, high)
    if (low == high-1) {
      return array[low]
    }
    else {
      mid = (low + high) / 2;
      maxLeft = findMax(array, low, mid)
      maxRight = findMax(array, mid+1, high)
      if maxLeft > maxRight
        return maxLeft
      else
        return maxRight
    }

    This would be called as findMax(array, 0, array.length).  As the program works by iteratively cutting the input before comparing n times, it has O(nlogn) efficiency.
