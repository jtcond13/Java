Test 2
================
Jack Condon


1.  Tree is below.  It has O(n) search efficiency, as in the worst case it must search 8 elements.  It is not a full binary tree
as only the first 3 levels have nodes which complete them.

                        60
                    /        \
                  30          80
                /    \       /  \
              20      40    70   90
            /           \           \
          10             50          100
         /
        5
       /
      3
     /
    2
   /
  1

2. Tree is below.  It has search efficiency of O(logn) as it must search 5 elements at the worst case.

                        60
                    /        \
                   5          80
                /    \       /  \
               3      40    70   90
             /  \    /   \         \
            2    10 30     50       100
          /        \
         1          20

3.

 k | 1 2 3 4 5 6 7 8 9 10 11 12
--------------------------------------------
A[k] 14
     14 40
     40 14
     40 14 26
     40 14 26 32
     40 32 26 14
     40 32 26 14 12
     40 32 26 14 12 45
     40 32 45 14 12 26
     45 40 32 14 12 26
     45 40 32 14 12 26 28
     45 40 32 14 12 26 28 9
     45 40 32 14 12 26 28 9 8
     45 40 32 14 12 26 28 9 8 16
     45 40 32 14 16 26 28 9 8 12
     45 40 32 14 16 26 28 9 8
     45 40 32 14 16 26 28 9

4.  Heap sort builds a heap with the input elements and then removes them in order.  Quick sort is a divide and conquer
sorting algorithm which choose a pivot point, assigns elements to the first or second half in comparison to the pivot (partitioning), then
recursively applies the method to each part of the list.  Both of these algorithms are in-place sorts (don't require additional space).
Heap sort has an overall efficiency of O(1.5logn) while QuickSort is usually O(nlogn) unless a bad pivot is chosen and the data is already sorted,
in which case it can have O(n^2) running time.

  Heapsort(A[n], precedes)                    QuickSort(A, lo, hi)
        int y := n / 2                            if (lo < hi) {
    while (y > 0) {                                 p = partition(A, lo, hi)
         downheap (A[n], y, precedes)               QuickSort(A, lo, p-1)
         y :=  y - 1                                QuickSort(A, p+1, hi)
     }
    y := n
    while (y > 1) {
        temp := A[1],    A[1] := A[y],
        A[y] := temp,    y := y - 1
        downheap(A[y], 1, precedes)
    }

5.  Tree is below.  This tree is not a heap as the nodes do not reflect an ordering property.

            5
          /   \
        1       2
      /   \    / \
     8     6  10  3
    / \   /
   9   4  7

6.
    1) 8
    3) 10 24 17
    4) 32

7.  Preorder traversal: */*+52-21++29--7218
    Postorder traversal /*+52-21++29--7218*

                  *
                /    \
              (/)      8
            /    \
          *        +
        /  \      / \
      +     -    +   -
    /  \   /  \ / \  / \
  5    2  2   1 2  9 -  1
                    / \
                  7     2

8.  A dictionary is an ordered or unordered list of key-element pairs, where keys are used to locate elements in the list.
All dictionaries have the following operations:

size ()                                      Returns the size of the dictionary
empty ()                                     Returns true is the dictionary is empty
findItem (key)                              Locates the item with the given key.
                                            than one item with the given key exists, an arbitrary item is returned.
findAllItems (key)                         Locates all items with the given key. .
removeItem (key)                           Removes the item with the given key
removeAllItems (key)                       Removes all items with the given key
insertItem (key, element)                  Inserts a new key-element pair

Ordered dictionaries also contain:

closestKeyBefore (key)           Returns the key of the item with largest key
                                  less than or equal to given key
closestElemBefore (key)          Returns the element for the item with largest
                                  key less than or equal to given key
closestKeyAfter (key)            Returns the key of the item with smallest
                                  key greater than or equal to given key
closestElemAfter (key)            Returns the element for the item with smallest
                                   key greater than or equal to given key

These methods allow new elements to be inserted at the correct places.  An unordered dictionary is best implemented as a hash table, with
findItem(), insertItem(), removeAllItems() and removeItem() having worst case running time of O(n/N), where n is the number of elements in the dictionary
and N is the number of hash buckets.  If there are no hash collisions, these become constant time (O(1)) operations.  An ordered dictionary is best
implemented as a binary search tree, providing O(logn) efficiency for insertItem(), removeItem(), removeAllItems() and findItem().  The size() and empty() methods
are constant time operations, simply accessing a class variable.
